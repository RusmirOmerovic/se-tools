#!/usr/bin/env bash
# supabase-setup – Intelligentes Setup für Supabase Credentials
# Verwendet bestehende Credentials oder fragt nach neuen, falls keine vorhanden

set -euo pipefail
IFS=$'\n\t'

SVC_URL="SUPABASE_URL"
SVC_ROLE="SUPABASE_SERVICE_ROLE"

detect_os() {
  case "$(uname -s | tr '[:upper:]' '[:lower:]')" in
    darwin*)   echo "macos" ;;
    linux*)    echo "linux" ;;
    msys*|mingw*|cygwin*) echo "windows" ;;
    *)         echo "unknown" ;;
  esac
}

trim_ws() { sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'; }

prompt_secret() { 
  local var; 
  read -r -p "$1: " var; 
  printf '%s' "$var" | tr -d '\r\n' | trim_ws; 
}

prompt_secret_hidden() { 
  local var; 
  read -r -s -p "$1: " var; 
  echo; 
  printf '%s' "$var" | tr -d '\r\n\t ' | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//'; 
}

# macOS Keychain Funktionen
get_macos() {
  local url role
  url=$(security find-generic-password -a "$USER" -s "$SVC_URL" -w 2>/dev/null || echo "")
  role=$(security find-generic-password -a "$USER" -s "$SVC_ROLE" -w 2>/dev/null || echo "")
  
  if [[ -n "$url" && -n "$role" ]]; then
    echo "$url|$role"
    return 0
  else
    return 1
  fi
}

store_macos() {
  local url="$1" role="$2"
  
  # Lösche bestehende Einträge
  security delete-generic-password -a "$USER" -s "$SVC_URL" 2>/dev/null || true
  security delete-generic-password -a "$USER" -s "$SVC_ROLE" 2>/dev/null || true
  
  # Speichere neue Werte
  if security add-generic-password -a "$USER" -s "$SVC_URL" -w "$url" &&
     security add-generic-password -a "$USER" -s "$SVC_ROLE" -w "$role"; then
    echo "🔐 Gespeichert in macOS Keychain."
    return 0
  else
    echo "❌ Fehler beim Speichern in Keychain."
    return 1
  fi
}

# Linux Funktionen
get_linux() {
  local url role
  if command -v secret-tool >/dev/null 2>&1; then
    url=$(secret-tool lookup service "$SVC_URL" account "$USER" 2>/dev/null || echo "")
    role=$(secret-tool lookup service "$SVC_ROLE" account "$USER" 2>/dev/null || echo "")
  else
    url=$(cat "$HOME/.config/se-tools/${SVC_URL}.txt" 2>/dev/null || echo "")
    role=$(cat "$HOME/.config/se-tools/${SVC_ROLE}.txt" 2>/dev/null || echo "")
  fi
  
  if [[ -n "$url" && -n "$role" ]]; then
    echo "$url|$role"
    return 0
  else
    return 1
  fi
}

store_linux() {
  local url="$1" role="$2"
  if command -v secret-tool >/dev/null 2>&1; then
    printf %s "$url"  | secret-tool store --label='se-tools' service "$SVC_URL"  account "$USER"
    printf %s "$role" | secret-tool store --label='se-tools' service "$SVC_ROLE" account "$USER"
    echo "🔐 Gespeichert in Secret Service (secret-tool)."
  else
    mkdir -p "$HOME/.config/se-tools"; chmod 700 "$HOME/.config/se-tools"
    umask 177
    printf %s "$url"  > "$HOME/.config/se-tools/${SVC_URL}.txt"
    printf %s "$role" > "$HOME/.config/se-tools/${SVC_ROLE}.txt"
    chmod 600 "$HOME/.config/se-tools/${SVC_URL}.txt" "$HOME/.config/se-tools/${SVC_ROLE}.txt"
    echo "🔐 Gespeichert als sichere Dateien."
  fi
}

# Windows Funktionen
get_windows() {
  local ps='
    try {
      $url = Get-Content $env:APPDATA\se-tools\SUPABASE_URL.txt -ErrorAction Stop
      $role = Get-Content $env:APPDATA\se-tools\SUPABASE_SERVICE_ROLE.txt -ErrorAction Stop
      $secU = ConvertTo-SecureString $url
      $secR = ConvertTo-SecureString $role
      $ptrU = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secU)
      $ptrR = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secR)
      $plainU = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptrU)
      $plainR = [System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ptrR)
      Write-Host "$plainU|$plainR"
    } catch {
      exit 1
    }
  '
  powershell.exe -NoProfile -Command "$ps" 2>/dev/null
}

store_windows() {
  local url="$1" role="$2"
  local ps='
    param([string]$Url,[string]$Role)
    New-Item -ItemType Directory -Force $env:APPDATA\se-tools | Out-Null
    $secU = ConvertTo-SecureString $Url  -AsPlainText -Force
    $encU = $secU | ConvertFrom-SecureString
    Set-Content $env:APPDATA\se-tools\SUPABASE_URL.txt $encU
    $secR = ConvertTo-SecureString $Role -AsPlainText -Force
    $encR = $secR | ConvertFrom-SecureString
    Set-Content $env:APPDATA\se-tools\SUPABASE_SERVICE_ROLE.txt $encR
  '
  powershell.exe -NoProfile -Command "$ps" -Url "$url" -Role "$role" >/dev/null 2>&1 || {
    echo "❌ PowerShell-Speicherung fehlgeschlagen."; return 1;
  }
  echo "🔐 Gespeichert mit DPAPI."
}

# Teste Credentials mit Supabase API
test_credentials() {
  local url="$1" role="$2"
  local http_code
  
  http_code=$(curl -s -o /dev/null -w "%{http_code}" \
    -H "apikey: $role" -H "Authorization: Bearer $role" \
    "$url/rest/v1/" 2>/dev/null || echo "CURL_FAILED")
  
  if [ "$http_code" = "200" ]; then
    return 0
  else
    echo "❌ Credentials ungültig (HTTP $http_code)"
    return 1
  fi
}

# Validiere JWT Token (Best-Effort)
validate_jwt() {
  local token="$1" expected_ref="$2"
  
  # Prüfe JWT Struktur (3 Teile)
  local parts_count=$(echo "$token" | tr '.' '\n' | wc -l | tr -d ' ')
  if [ "$parts_count" -ne 3 ]; then
    echo "❌ JWT hat $parts_count Teile statt 3 - Token ist ungültig!"
    return 1
  fi
  
  # Best-effort Ref-Validierung (falls jq verfügbar)
  if command -v jq >/dev/null 2>&1; then
    local payload_encoded=$(echo "$token" | awk -F. '{print $2}')
    local padded_payload="$payload_encoded"
    local pad_length=$(( (4 - (${#payload_encoded} % 4)) % 4 ))
    for ((i=0; i<pad_length; i++)); do
      padded_payload="${padded_payload}="
    done
    
    local decoded_payload
    decoded_payload=$(echo "$padded_payload" | tr '_-' '/+' | base64 -D 2>/dev/null || echo "")
    
    if [ -n "$decoded_payload" ]; then
      local actual_ref=$(echo "$decoded_payload" | jq -r '.ref // empty' 2>/dev/null || echo "")
      if [ -n "$actual_ref" ] && [ "$actual_ref" != "$expected_ref" ]; then
        echo "❌ Service-Role gehört zu Projekt '$actual_ref', aber URL zeigt auf '$expected_ref'"
        return 1
      fi
    fi
  fi
  
  return 0
}

# Hauptfunktion
main() {
  local OS="$(detect_os)"
  if [[ "$OS" == "unknown" ]]; then 
    echo "❌ Nicht unterstütztes OS."; 
    exit 1
  fi

  echo "🔧 Supabase Credentials Setup"
  echo "=============================="
  
  # Prüfe ob bereits Credentials vorhanden sind
  echo "→ Prüfe bestehende Credentials..."
  local existing_creds=""
  case "$OS" in
    macos)   existing_creds=$(get_macos 2>/dev/null || echo "") ;;
    linux)   existing_creds=$(get_linux 2>/dev/null || echo "") ;;
    windows) existing_creds=$(get_windows 2>/dev/null || echo "") ;;
  esac
  
  if [[ -n "$existing_creds" ]]; then
    local existing_url=$(echo "$existing_creds" | cut -d'|' -f1)
    local existing_role=$(echo "$existing_creds" | cut -d'|' -f2)
    
    echo "✅ Bestehende Credentials gefunden:"
    echo "   URL: $existing_url"
    echo "   Role: ${existing_role:0:30}...${existing_role: -10}"
    echo ""
    
    # Teste bestehende Credentials
    echo "→ Teste bestehende Credentials..."
    if test_credentials "$existing_url" "$existing_role"; then
      echo "✅ Bestehende Credentials sind gültig!"
      echo ""
      echo "Verwendung in Scripts:"
      echo "  export SUPABASE_URL='$existing_url'"
      echo "  export SUPABASE_SERVICE_ROLE='$existing_role'"
      echo ""
      
      # Frage ob neue Credentials eingegeben werden sollen
      echo "Möchtest du neue Credentials eingeben? (y/N)"
      local answer
      read -r answer
      if [[ ! "$answer" =~ ^[Yy]$ ]]; then
        echo "👍 Verwende bestehende Credentials."
        exit 0
      fi
    else
      echo "⚠️ Bestehende Credentials sind ungültig - neue Eingabe erforderlich."
    fi
  else
    echo "ℹ️ Keine bestehenden Credentials gefunden."
  fi
  
  echo ""
  echo "→ Neue Supabase Credentials eingeben:"
  echo "   (Kopiere sie aus: https://supabase.com/dashboard/project/YOUR_PROJECT/settings/api)"
  echo ""
  
  # Neue Credentials abfragen
  local url role
  url="$(prompt_secret 'SUPABASE_URL (z.B. https://xyz.supabase.co)')"
  role="$(prompt_secret_hidden 'SUPABASE_SERVICE_ROLE (JWT Token)')"
  
  [[ -z "$url" || -z "$role" ]] && { echo "❌ Beide Werte erforderlich."; exit 1; }
  
  # Bereinige URL
  url="${url%/}"
  
  # Extrahiere Projekt-Ref aus URL für Validierung
  local expected_ref="$(echo "$url" | sed -E 's#https?://([^./]+)\.supabase\.co.*#\1#')"
  
  echo ""
  echo "→ Validiere neue Credentials..."
  
  # Validiere JWT Token
  if ! validate_jwt "$role" "$expected_ref"; then
    echo "   Tipp: Verwende den 'service_role' Key, nicht den 'anon' Key!"
    exit 1
  fi
  
  # Teste mit Supabase API
  if ! test_credentials "$url" "$role"; then
    echo "   Tipp: Kopiere den exakten Service Role Key aus der Supabase Console."
    exit 1
  fi
  
  echo "✅ Neue Credentials sind gültig!"
  echo ""
  
  # Speichere neue Credentials
  echo "→ Speichere Credentials..."
  case "$OS" in
    macos)   store_macos "$url" "$role" ;;
    linux)   store_linux "$url" "$role" ;;
    windows) store_windows "$url" "$role" ;;
  esac
  
  # Finale Bestätigung
  echo ""
  echo "✅ Setup abgeschlossen!"
  echo ""
  echo "Verwendung in Scripts:"
  echo "  export SUPABASE_URL='$url'"
  echo "  export SUPABASE_SERVICE_ROLE='$role'"
  echo ""
  echo "Oder lade sie automatisch:"
  echo "  eval \"\$(./supabase-setup --export)\""
}

# Export-Modus für andere Scripts
if [ "${1:-}" = "--export" ]; then
  local OS="$(detect_os)"
  local existing_creds=""
  
  case "$OS" in
    macos)   existing_creds=$(get_macos 2>/dev/null || echo "") ;;
    linux)   existing_creds=$(get_linux 2>/dev/null || echo "") ;;
    windows) existing_creds=$(get_windows 2>/dev/null || echo "") ;;
  esac
  
  if [[ -n "$existing_creds" ]]; then
    local url=$(echo "$existing_creds" | cut -d'|' -f1)
    local role=$(echo "$existing_creds" | cut -d'|' -f2)
    echo "export SUPABASE_URL='$url'"
    echo "export SUPABASE_SERVICE_ROLE='$role'"
  else
    echo "echo '❌ Keine Supabase Credentials gefunden. Führe ./supabase-setup aus.'" >&2
    exit 1
  fi
  exit 0
fi

# Hilfe
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
  echo "Supabase Credentials Setup"
  echo "=========================="
  echo ""
  echo "Verwendung:"
  echo "  $0              # Interaktives Setup"
  echo "  $0 --export     # Exportiere bestehende Credentials"
  echo "  $0 --help       # Diese Hilfe"
  echo ""
  echo "Das Script:"
  echo "- Prüft bestehende Credentials und testet sie"
  echo "- Fragt nach neuen Credentials falls keine vorhanden oder ungültig"
  echo "- Validiert JWT Token und testet API-Zugriff"
  echo "- Speichert sicher im System (Keychain/Secret Service/DPAPI)"
  exit 0
fi

main "$@"
